name: application-nginx-pipeline

on:
  workflow_dispatch:

  push:
    branches:
      - main
    paths:
      - "dockerfile/podinfo/**"

permissions:
      id-token: write   
      contents: read    

run-name: podinfo → ecr → lambda

jobs:
  build_and_push:
    runs-on: ubuntu-latest

    steps:
    # ---------- Lint & Test (go test ./... su Podinfo) ----------
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.22"

      - name: Clone Podinfo (for tests)
        run: |
          git clone --depth=1 https://github.com/stefanprodan/podinfo.git ./_podinfo
          cd _podinfo
          go test ./...

    #  ---------- Build (multi-arch) ----------
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Define bake file (docker-bake.hcl)
        run: |
          cat > docker-bake.hcl <<'EOF'
          group "default" {
            targets = ["podinfo-lambda"]
          }
          target "podinfo-lambda" {
            context = "dockerfile/podinfo"
            dockerfile = "Dockerfile"
            platforms = ["linux/amd64","linux/arm64"]
            # Niente push: esportiamo un'OCI image tar
            # (buildx supporta multi-arch solo con export o push; --load è solo single-arch)
            output = ["type=oci,dest=podinfo-lambda-${{ github.sha }}.tar"]
          }
          EOF

      - name: Build (multi-arch) to OCI tar
        run: |
          docker buildx bake --file docker-bake.hcl

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: podinfo-lambda-oci-${{ github.sha }}
          path: podinfo-lambda-${{ github.sha }}.tar
      
      # ---------- Login to ECR (OIDC)) ----------
      - name: Read OIDC role from repo vars
        shell: bash
        env:
          AUTOMATION_PROD: ${{ vars.AUTOMATION_PROD }}
        run: |
          export AWS_ACCOUNT_ID=$(echo "$AUTOMATION_PROD" | jq -r '.AWS_ACCOUNT_ID')
          export AWS_IAM_ROLE=$(echo "$AUTOMATION_PROD" | jq -r '.AWS_IAM_ROLE')
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "AWS_IAM_ROLE=$AWS_IAM_ROLE"     >> $GITHUB_ENV
          echo "AWS_REGION=eu-central-1"        >> $GITHUB_ENV   
          echo "ECR_REPO_NAME=orbital-freight-podinfo-repo" >> $GITHUB_ENV

      
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_IAM_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: podinfo-ci

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # ---------- Push (install skopeo to use tar file) ----------
      - name: Install skopeo
        run: |
          sudo apt-get update -y
          sudo apt-get install -y skopeo

  
      - name: Skopeo login to ECR
        env:
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | skopeo login --username AWS --password-stdin \
              "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Push OCI tar to ECR
        env:
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REPO_NAME: ${{ env.ECR_REPO_NAME }}
        run: |
          TAR="podinfo-lambda-${{ github.sha }}.tar"
          ECR_URL="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"

          # Copia multi-arch (manifest list) dal tar al registry
          skopeo copy --all --retry-times 3 \
            oci-archive:${TAR} docker://${ECR_URL}:${{ github.sha }}

          skopeo copy --all --retry-times 3 \
            oci-archive:${TAR} docker://${ECR_URL}:latest
    
      # ---------- Deploy ----------
      - name: Resolve Lambda/CD env
        shell: bash
        env: 
          LAMBDA: ${{ vars.LAMBDA }}
        run:
          export LAMBDA_FUNCTION_NAME=$(echo "$LAMBDA" | jq -r '.LAMBDA_FUNCTION_NAME')
          export LAMBDA_ALIAS=$(echo "$LAMBDA" | jq -r '.LAMBDA_ALIAS')
          export CD_APP_NAME=$(echo "$LAMBDA" | jq -r '.CD_APP_NAME')
          export CD_DG_NAME=$(echo "$LAMBDA" | jq -r '.CD_DG_NAME')

          echo "LAMBDA_FUNCTION_NAME=$LAMBDA_FUNCTION_NAME" >> $GITHUB_ENV
          echo "LAMBDA_ALIAS=$LAMBDA_ALIAS"     >> $GITHUB_ENV
          echo "CD_APP_NAME=$CD_APP_NAME"        >> $GITHUB_ENV   
          echo "CD_DG_NAME=$CD_DG_NAME" >> $GITHUB_ENV

      - name: Update Lambda code (publish new version)
        id: lambda-update
        shell: bash
        env:
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          ECR_REPO_NAME: ${{ env.ECR_REPO_NAME }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          ECR_URL="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          NEW_VERSION=$(aws lambda update-function-code \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --image-uri "${ECR_URL}:${{ github.sha }}" \
            --publish \
            --query 'Version' --output text)
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "New Lambda version: $NEW_VERSION"

      - name: Read current alias version
        id: lambda-alias
        shell: bash
        env:
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          LAMBDA_ALIAS: ${{ env.LAMBDA_ALIAS }}
        run: |
          set -e
          CURR_VERSION=$(aws lambda get-alias \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --name "${LAMBDA_ALIAS}" \
            --query 'FunctionVersion' --output text)
          echo "CURR_VERSION=$CURR_VERSION" >> $GITHUB_ENV
          echo "Current alias version: $CURR_VERSION"

      - name: Create CodeDeploy deployment
        id: create-deploy
        shell: bash
        env:
          CD_APP_NAME: ${{ env.CD_APP_NAME }}
          CD_DG_NAME: ${{ env.CD_DG_NAME }}
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          LAMBDA_ALIAS: ${{ env.LAMBDA_ALIAS }}
          CURR_VERSION: ${{ env.CURR_VERSION }}
          NEW_VERSION: ${{ env.NEW_VERSION }}
        run: |
          set -e
          cat > appspec.yaml << 'YAML'
          version: 0.0
          Resources:
            - myLambda:
                Type: AWS::Lambda::Function
                Properties:
                  Name: ${LAMBDA_FUNCTION_NAME}
                  Alias: ${LAMBDA_ALIAS}
                  CurrentVersion: ${CURR_VERSION}
                  TargetVersion: ${NEW_VERSION}
          YAML
          sed -i "s|\${LAMBDA_FUNCTION_NAME}|${LAMBDA_FUNCTION_NAME}|g" appspec.yaml
          sed -i "s|\${LAMBDA_ALIAS}|${LAMBDA_ALIAS}|g" appspec.yaml
          sed -i "s|\${CURR_VERSION}|${CURR_VERSION}|g" appspec.yaml
          sed -i "s|\${NEW_VERSION}|${NEW_VERSION}|g" appspec.yaml

          DEPLOY_ID=$(aws deploy create-deployment \
            --application-name "${CD_APP_NAME}" \
            --deployment-group-name "${CD_DG_NAME}" \
            --revision "appSpecContent={content='$(awk '{printf "%s\\n", $0}' appspec.yaml)'}" \
            --description "podinfo ${{ github.sha }}" \
            --query 'deploymentId' --output text)
          echo "DEPLOY_ID=$DEPLOY_ID" >> $GITHUB_ENV
          echo "Deployment: $DEPLOY_ID"

      # (opzionale ma consigliato) Attendi il completamento del canary + bake time
      - name: Wait for CodeDeploy to complete
        shell: bash
        run: |
          set -e
          aws deploy wait deployment-successful --deployment-id "$DEPLOY_ID"
          echo "Deployment successful."


      

