name: application-nginx-pipeline

on:
  workflow_dispatch:

  push:
    branches:
      - main
    paths:
      - "dockerfile/podinfo/**"

permissions:
      id-token: write   
      contents: read    

run-name: podinfo → ecr → lambda

jobs:
  build_and_push:
    runs-on: ubuntu-latest

    steps:
    # ---------- Lint & Test (go test ./... su Podinfo) ----------
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.22"

      - name: Clone Podinfo (for tests)
        run: |
          git clone --depth=1 https://github.com/stefanprodan/podinfo.git ./_podinfo
          cd _podinfo
          go test ./...

    #  ---------- Build (multi-arch) ----------
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Define bake file (docker-bake.hcl)
        run: |
          cat > docker-bake.hcl <<'EOF'
          group "default" {
            targets = ["podinfo-lambda"]
          }
          target "podinfo-lambda" {
            context = "dockerfile/podinfo"
            dockerfile = "Dockerfile"
            platforms = ["linux/amd64","linux/arm64"]
            # Niente push: esportiamo un'OCI image tar
            # (buildx supporta multi-arch solo con export o push; --load è solo single-arch)
            output = ["type=oci,dest=podinfo-lambda-${{ github.sha }}.tar"]
          }
          EOF

      - name: Build (multi-arch) to OCI tar
        run: |
          docker buildx bake --file docker-bake.hcl

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: podinfo-lambda-oci-${{ github.sha }}
          path: podinfo-lambda-${{ github.sha }}.tar
      
      # ---------- Login to ECR (OIDC)) ----------
      - name: Read OIDC role from repo vars
        shell: bash
        env:
          AUTOMATION_PROD: ${{ vars.AUTOMATION_PROD }}
        run: |
          export AWS_ACCOUNT_ID=$(echo "$AUTOMATION_PROD" | jq -r '.AWS_ACCOUNT_ID')
          export AWS_IAM_ROLE=$(echo "$AUTOMATION_PROD" | jq -r '.AWS_IAM_ROLE')
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "AWS_IAM_ROLE=$AWS_IAM_ROLE"     >> $GITHUB_ENV
          echo "AWS_REGION=eu-central-1"        >> $GITHUB_ENV   
          echo "ECR_REPO_NAME=orbital-freight-podinfo-repo" >> $GITHUB_ENV

      
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_IAM_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: podinfo-ci

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # ---------- Push (install skopeo to use tar file) ----------
      - name: Install skopeo
        run: |
          sudo apt-get update -y
          sudo apt-get install -y skopeo

  
      - name: Skopeo login to ECR
        env:
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | skopeo login --username AWS --password-stdin \
              "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Push OCI tar to ECR
        env:
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REPO_NAME: ${{ env.ECR_REPO_NAME }}
        run: |
          TAR="podinfo-lambda-${{ github.sha }}.tar"
          ECR_URL="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"

          # Copia multi-arch (manifest list) dal tar al registry
          skopeo copy --all --retry-times 3 \
            oci-archive:${TAR} docker://${ECR_URL}:${{ github.sha }}

          skopeo copy --all --retry-times 3 \
            oci-archive:${TAR} docker://${ECR_URL}:latest
          
      # Estrai il digest dell'INDEX multi-arch dal tag :sha
      - name: Get manifest-list (index) JSON
        id: get-index
        shell: bash
        env:
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REPO_NAME: ${{ env.ECR_REPO_NAME }}
        run: |
          set -euo pipefail
          ECR_URL="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          # Prendo il manifest dell'INDEX (Docker v2 list o OCI index)
          INDEX=$(aws ecr batch-get-image \
            --repository-name "${ECR_REPO_NAME}" \
            --image-id imageTag="${GITHUB_SHA}" \
            --accepted-media-types 'application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.oci.image.index.v1+json' \
            --query 'images[0].imageManifest' --output text)
          echo "$INDEX" > index.json
          cat index.json | jq -r '.manifests[] | {mediaType, platform, digest}'

          # Trova il digest del manifest per amd64
          AMD64_DIGEST=$(jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest' index.json)
          test -n "$AMD64_DIGEST" || { echo "::error::No amd64 digest found in manifest list"; exit 1; }
          echo "AMD64_DIGEST=$AMD64_DIGEST" >> $GITHUB_ENV
          echo "Resolved amd64 digest: $AMD64_DIGEST"

      # (Facoltativo ma consigliato) Fai emit del manifest figlio in formato Docker v2
      - name: Get amd64 child manifest (docker v2)
        id: get-child
        shell: bash
        env:
          ECR_REPO_NAME: ${{ env.ECR_REPO_NAME }}
          AMD64_DIGEST: ${{ env.AMD64_DIGEST }}
        run: |
          set -euo pipefail
          CHILD=$(aws ecr batch-get-image \
            --repository-name "${ECR_REPO_NAME}" \
            --image-id imageDigest="${AMD64_DIGEST}" \
            --accepted-media-types 'application/vnd.docker.distribution.manifest.v2+json,application/vnd.oci.image.manifest.v1+json' \
            --query 'images[0].imageManifest' --output text)
          echo "$CHILD" | jq . | sed -e 's/^/CHILD: /' || true

    
      # ---------- Deploy ----------
      - name: Resolve Lambda/CD env
        shell: bash
        env: 
          LAMBDA: ${{ vars.LAMBDA }}
        run: |
          export LAMBDA_FUNCTION_NAME=$(echo "$LAMBDA" | jq -r '.LAMBDA_FUNCTION_NAME')
          export LAMBDA_ALIAS=$(echo "$LAMBDA" | jq -r '.LAMBDA_ALIAS')
          export CD_APP_NAME=$(echo "$LAMBDA" | jq -r '.CD_APP_NAME')
          export CD_DG_NAME=$(echo "$LAMBDA" | jq -r '.CD_DG_NAME')

          echo "LAMBDA_FUNCTION_NAME=$LAMBDA_FUNCTION_NAME" >> $GITHUB_ENV
          echo "LAMBDA_ALIAS=$LAMBDA_ALIAS"     >> $GITHUB_ENV
          echo "CD_APP_NAME=$CD_APP_NAME"        >> $GITHUB_ENV   
          echo "CD_DG_NAME=$CD_DG_NAME" >> $GITHUB_ENV

      - name: Update Lambda code (publish new version)
        id: lambda-update
        shell: bash
        env:
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          ECR_REPO_NAME: ${{ env.ECR_REPO_NAME }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          ECR_URL="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          IMAGE_URI="${ECR_URL}@${AMD64_DIGEST}"
          echo "Updating ${LAMBDA_FUNCTION_NAME} with image ${IMAGE_URI}"
          NEW_VERSION=$(aws lambda update-function-code \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --image-uri "$IMAGE_URI" \
            --publish \
            --query 'Version' --output text)
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "New Lambda version: $NEW_VERSION"

      - name: Read current alias version
        id: lambda-alias
        shell: bash
        env:
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          LAMBDA_ALIAS: ${{ env.LAMBDA_ALIAS }}
        run: |
          set -e
          CURR_VERSION=$(aws lambda get-alias \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --name "${LAMBDA_ALIAS}" \
            --query 'FunctionVersion' --output text)
          echo "CURR_VERSION=$CURR_VERSION" >> $GITHUB_ENV
          echo "Current alias version: $CURR_VERSION"

      - name: Create CodeDeploy deployment
        id: create-deploy
        shell: bash
        env:
          CD_APP_NAME: ${{ env.CD_APP_NAME }}
          CD_DG_NAME: ${{ env.CD_DG_NAME }}
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          LAMBDA_ALIAS: ${{ env.LAMBDA_ALIAS }}
          CURR_VERSION: ${{ env.CURR_VERSION }}
          NEW_VERSION: ${{ env.NEW_VERSION }}
        run: |
          set -e
          cat > appspec.yaml << 'YAML'
          version: 0.0
          Resources:
            - myLambda:
                Type: AWS::Lambda::Function
                Properties:
                  Name: ${LAMBDA_FUNCTION_NAME}
                  Alias: ${LAMBDA_ALIAS}
                  CurrentVersion: ${CURR_VERSION}
                  TargetVersion: ${NEW_VERSION}
          YAML
          sed -i "s|\${LAMBDA_FUNCTION_NAME}|${LAMBDA_FUNCTION_NAME}|g" appspec.yaml
          sed -i "s|\${LAMBDA_ALIAS}|${LAMBDA_ALIAS}|g" appspec.yaml
          sed -i "s|\${CURR_VERSION}|${CURR_VERSION}|g" appspec.yaml
          sed -i "s|\${NEW_VERSION}|${NEW_VERSION}|g" appspec.yaml

          # Leggi il file YAML e trasformalo in stringa JSON correttamente quotata
          CONTENT=$(jq -Rs . appspec.yaml)

          # Monta l'input per --revision specificando revisionType=AppSpecContent
          REVISION_JSON=$(printf '{"revisionType":"AppSpecContent","appSpecContent":{"content":%s}}' "$CONTENT")

          # Crea il deployment
          DEPLOY_JSON=$(aws deploy create-deployment \
            --application-name "${CD_APP_NAME}" \
            --deployment-group-name "${CD_DG_NAME}" \
            --revision "${REVISION_JSON}" \
            --description "podinfo ${GITHUB_SHA}")

          DEPLOY_ID=$(echo "$DEPLOY_JSON" | jq -r .deploymentId)
          echo "DEPLOY_ID=$DEPLOY_ID" >> $GITHUB_ENV
          echo "Deployment: $DEPLOY_ID"

      # Waiting canary + bake time
      - name: Wait for CodeDeploy to complete
        shell: bash
        run: |
          set -e
          aws deploy wait deployment-successful --deployment-id "$DEPLOY_ID"
          echo "Deployment successful."

      # ---------- Verify ----------
      - name: Verify deployment (health check)
        shell: bash
        env:
          API_URL: ${{ vars.API_URL }}
        run: |
          set -euo pipefail
          echo "Checking health at $API_URL/healthz ..."
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/healthz" || true)
          if [ "$STATUS" != "200" ]; then
            echo "::error::Health check failed, got HTTP $STATUS"
            exit 1
          fi
          echo "Health check OK"

      # ---------- Additional Step: Print Masked Secret Value ----------
      - name: Write secret to CloudWatch logs (masking demo)
        shell: bash
        env:
          LAMBDA_FUNCTION_NAME: ${{ env.LAMBDA_FUNCTION_NAME }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          # ARN del secret dalle env della Lambda
          SECRET_ARN=$(aws lambda get-function-configuration \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --query 'Environment.Variables.SUPER_SECRET_TOKEN_SECRET_ARN' \
            --output text)

          # Valore del secret
          SECRET_VALUE=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_ARN" \
            --query 'SecretString' --output text)

          # Scrivi un messaggio nel log group della Lambda
          LOG_GROUP="/aws/lambda/${LAMBDA_FUNCTION_NAME}"
          LOG_STREAM="masking-demo-${GITHUB_SHA}"
          aws logs create-log-stream --log-group-name "$LOG_GROUP" --log-stream-name "$LOG_STREAM" || true

          TS_MS=$(( $(date +%s) * 1000 ))
          aws logs put-log-events \
            --log-group-name "$LOG_GROUP" \
            --log-stream-name "$LOG_STREAM" \
            --log-events timestamp=$TS_MS,message="DEMO: SUPER_SECRET_TOKEN=${SECRET_VALUE}"




      

